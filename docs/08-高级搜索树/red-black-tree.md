# red-black-tree

## 红黑树的动机

总结的说：为了具备对历史版本的访问，实现 Persistent structrure ，引入了平衡树，AVL的删除操作无法做到常量级，所以引出了红黑树。

线性结构：向量、列表、栈、队列

半线性结构：树

非线性结构：图

都属于是 ephemeral 结构，状态稍纵即逝。

Persistent structrure：支持对历史版本的访问

T.search(ver, key); T.insert(ver, key); T.remove(ver, key);

蛮力实现：每个版本独立保存；各版本入口自成一格搜索结构

单次操作（logh + logn），累计h*n 时间/空间  h = |history|

挑战：可否将复杂度控制在 (n + h*logn)

可以： 相邻版本之间的关联性

08XA1-4 O(1)重构

**关联性**：大量共享，少量更新：每个版本的新增复杂度为 logn

能否进一步提高，比如总体O(n+h)、单版本O(1)?可以

**就树形结构拓扑而言，相邻版本之间的差异不能超过O(1) 常数级别**

AVL insert 操作 满足 O(1) remove 操作 Ologn

红黑树 的 insert remove 可以满足 O(1) 常数级别的要求

## 红黑树的结构

BBST 二叉搜索树

lifting 上浮 提升  -> 提升变换

末端结点

(2, 4) 4 阶的 B 树 == 红黑树

平衡性 
定理：包含n个内部结点的红黑树T，高度h=O(logn)

$\log_2{(n+1)}$ $\leq$ h $\leq$ 2*$\log_2{(n+1)}$

若 T 高度为 h，黑高度为H，则 h = R + H <= 2H

若T所对应的B树为$T_B$，则H即是$T_B$的高度

$T_B$的每个结点，包含且仅包含T的一个黑结点

于是 H $\leq$ $log_[4/2]{\frac{n+1}{2}+1}$ $\leq$ $log_2{(n+1)}$

### 接口定义 C++

```c++
template <typename T> class RedBlack : public BST<T> {
  public: // BST::search()等其余接口可直接沿用
             BinNodePosi(T) inert( const T & e ); // 插入（重写）
             bool remove( const T & e ); // 删除（重写）
  protected: void solveDoubleRed( BinNodePosi(T) x ); // 双红修正
             void solveDoubleBlack( BinNodePosi(T) x ); // 双黑修正
             int updateHeight ( BinNodePosi(T) x ); // 更新结点x的高度（黑高度）
};
template <typename T> int RedBlack<T>::updateHeight( BinNodePosi(T) x ) {
  x->height = max( stature( x->lc ), stature( x->rc ) );
  if ( IsBlack( x ) ) x->height++; return x->height; // 只计黑结点
}
```

## 红黑树-插入

rb-tree  B-tree

### 红黑树操作

#### 变色 旋转

左旋
<!-- 当前结点的父结点指针指向当前结点的右子结点
当前结点的右子结点指针指向当前结点的右子结点的左子结点
当前结点的右子节点的左子结点指针指向当前结点 -->

右旋

#### 插入 删除 查找

插入结点：
和二叉查找树插入操作一致，多了平衡调整操作。新结点默认是红色结点，只有插入到红色结点下时才需要调整，分下面3种情况；

1. 叔叔结点是红色

   变色，递归往上变色，根结点必须是黑色

2. 叔叔结点是黑色，祖父、父亲、新结点在同一侧

   旋转一次，父结点变黑色，兄弟结点变红色

3. 叔叔结点是黑色，祖父、父亲、新结点不在同一侧

   旋转一次，执行第2步（旋转一次，父结点变黑色，兄弟结点变红色）

删除结点：

红黑树结点删除和二叉查找树结点删除过程一样，最后多一步平衡调整操作。只有删除黑色结点需要平衡调整（1. 删除红色结点时不需要平衡调整，没破坏红黑树规则 2. 删除黑色结点后，会违反从任意节点到叶子节点的每条路径包含的黑色节点数目相同的规则），分以下情况：

删除只有一个子结点，该情况子结点颜色必为红色（如果子结点是黑色，那么破坏了红黑树的第5条规则，该结点的左右黑色结点数为2:1，不平衡），只需将子结点由红色改为黑色即可

删除没有子结点的结点，情况比较复杂，分4种情况

1. 待删除结点的兄弟结点是红色

   左旋(或右旋)，然后原父亲结点和兄弟结点颜色互换，则可以变为后面的结点删除情况（情况二、情况三、情况四）来处理

2. 待删除结点的兄弟节点是黑色，且兄弟结点的两个孩子都是黑色（黑黑）（主要是变色调整）

   如果父亲结点是红色，只需将兄弟结点改为红色，父亲结点改为黑色，删除结点即可

   如果父亲结点是黑色，则只需将兄弟结点改为红色，删除该结点，然后把父亲结点当起点，继续进行平衡调整（但不会删除父结点）

3. 待删除结点的兄弟节点是黑色，且远侄子结点是红色（红红、黑红）（一次旋转，颜色互换）

   该情况将父结点和兄弟结点颜色互换，并进行左旋（或右旋）操作，最后把远侄子结点颜色变为黑色，并删除结点即可

4. 待删除结点的兄弟节点是黑色，且近侄子结点是红色，远侄子是黑色（红黑）

   先右旋（或左旋），并交换原兄弟结点和近侄子结点的颜色，则变成情况三

## 红黑树-删除
