# Tree

## 定义

### 相关术语

结点：包含数据元素和若干指向其他结点的分支信息的数据结构

结点的度：结点拥有子树的个数叫该结点的度

叶子结点：度为0的结点，或称终端结点

分支结点：度不为0的结点

孩子结点、父亲结点、兄弟结点：树中一个结点的子树的根结点成为这个结点的孩子结点，这个结点称为孩子结点的父亲结点，具有同一个父亲结点的孩子结点互称为兄弟结点

结点层次：根结点层次为1，其余结点层次等于父亲结点层次加1

祖先、子孙：树中有路径从m到n，则m为n的祖先，n为m的子孙

树的深度：树中所有结点的层次的最大数

树的度：树中所有结点的度的最大值

森林：m(m>0)棵不相交的树的集合称为森林

## 满二叉树 完全二叉树

二叉树是一棵树，其中每个结点都不能有多于两个孩子结点

五种基本形态：空，根，根左，根右，根左右

### 特殊二叉树-斜树

所有结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫做右斜树

结点个数与二叉树深度相同。其实就是线性表，线性表是树的一种特殊形式。

### 特殊二叉树-满二叉树

二叉树中，如果所有分支结点都存在左子树和右子树，且所有叶子都在同一层上，这样的二叉树称为满二叉树。

非叶子结点的度都为2

二叉树中，满二叉树的结点个数最多，叶子结点数最多

### 特殊二叉树-完全二叉树

对一棵具有n个结点的二叉树按层序编号，如果编号为i(1 <= i <= n)的结点与同样深度的满二叉树中编号为i的结点在二叉树的位置完全相同，则称这棵树为完全二叉树。

叶子结点只能出现最下两层

最下层的叶子一定集中在左部连续位置

倒数二层，若有叶子结点，一定在右部连续位置

如果有结点 度为1，则该结点只有左孩子

同样结点的二叉树，完全二叉树深度最小

## 二叉树的性质

性质1：二叉树的第i层上至多有 2^(i-1) 个结点(i>=1)

性质2：深度为k的二叉树至多有 2^k - 1 个结点(k>=1)

性质3：对于一棵非空二叉树，如果叶子结点数为n0，度数为2的结点数为n2，则有n0=n2+1

性质4：具有n个结点的完全二叉树深度为[log2n] + 1 ([x]表示不大于x的最大整数)

性质5：如果对一棵树有n个结点的完全二叉树的结点按层序编号，则对任一结点(1<=i<=n)，有：

1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是 [i/2]

2. 如果2i>n，则结点i无左孩子；如果2i<=n，则其左孩子是2i

3. 如果2i+1>n，则结点i无右孩子；如果2i+1<=n，则其右孩子是2i+1

## 二叉树的顺序存储 和 链式存储 结构

数组  链表  表示二叉树

```c
// 链表 表示二叉树 结点
typedef struct tree_node {
  elemtype data; // 数据域
  struct node *lchild, *rchild; // 指针域
} tree_node_t;
```

## 二叉树的遍历 前序 中序 后序 层次遍历算法

```c
// 前序遍历 根左右
void PreOrder(BiTree bt)
{
  if(bt == NULL) return;
  visit(bt->data);
  PreOrder(bt->lchild);
  PreOrder(bt->rchild);
}
// 中序遍历 左根右
void MidOrder(BiTree bt)
{
  if(bt == NULL) return;
  MidOrder(bt->lchild);
  visit(bt->data);
  MidOrder(bt->rchild);
}
// 后序遍历 左右根
void PostOrder(BiTree bt)
{
  if(bt == NULL) return;
  PostOrder(bt->lchild);
  PostOrder(bt->rchild);
  visit(bt->data);
}
// 层次遍历
// TODO
```

## 二叉搜索树的定义和操作

**二叉查找树** **二叉搜索树** **二叉排序树** 是一个意思

```c
// 查找

// 插入

// 删除

```

删除结点右三种情况，叶子结点，结点有一个子结点，结点有两个子结点

结点有两个子结点情况稍微复杂一点。**将删除结点和左子树的最大结点或者右子树的最小结点进行交换（递归查找）**，然后把交换后，删除结点的父结点指向删除结点的指针指为NULL，free(删除结点)就可以了。

## 红黑树的定义和操作

定义

满足以下条件的二叉排序树，则为一棵红黑树

1. 每个结点要么是红色，要么是黑色

2. 根结点是黑色

3. 每个叶结点(NIL)是黑色

4. 如果结点是红色，则它两个儿子结点都是黑色（并没有要求黑色结点的两个儿子都必须是红色!!!）

5. 对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点

性质

最坏情况 O(logN)时间

红黑树的高度最多2log(N+1)

### 红黑树操作

#### 变色 旋转

左旋
<!-- 当前结点的父结点指针指向当前结点的右子结点
当前结点的右子结点指针指向当前结点的右子结点的左子结点
当前结点的右子节点的左子结点指针指向当前结点 -->

右旋

#### 插入 删除 查找

插入结点：
和二叉查找树插入操作一致，多了平衡调整操作。新结点默认是红色结点，只有插入到红色结点下时才需要调整，分下面3种情况；

1. 叔叔结点是红色

   变色，递归往上变色，根结点必须是黑色

2. 叔叔结点是黑色，祖父、父亲、新结点在同一侧

   旋转一次，父结点变黑色，兄弟结点变红色

3. 叔叔结点是黑色，祖父、父亲、新结点不在同一侧

   旋转一次，执行第2步（旋转一次，父结点变黑色，兄弟结点变红色）

删除结点：

红黑树结点删除和二叉查找树结点删除过程一样，最后多一步平衡调整操作。只有删除黑色结点需要平衡调整（1. 删除红色结点时不需要平衡调整，没破坏红黑树规则 2. 删除黑色结点后，会违反从任意节点到叶子节点的每条路径包含的黑色节点数目相同的规则），分以下情况：

删除只有一个子结点，该情况子结点颜色必为红色（如果子结点是黑色，那么破坏了红黑树的第5条规则，该结点的左右黑色结点数为2:1，不平衡），只需将子结点由红色改为黑色即可

删除没有子结点的结点，情况比较复杂，分4种情况

1. 待删除结点的兄弟结点是红色

   左旋(或右旋)，然后原父亲结点和兄弟结点颜色互换，则可以变为后面的结点删除情况（情况二、情况三、情况四）来处理

2. 待删除结点的兄弟节点是黑色，且兄弟结点的两个孩子都是黑色（黑黑）（主要是变色调整）

   如果父亲结点是红色，只需将兄弟结点改为红色，父亲结点改为黑色，删除结点即可

   如果父亲结点是黑色，则只需将兄弟结点改为红色，删除该结点，然后把父亲结点当起点，继续进行平衡调整（但不会删除父结点）

3. 待删除结点的兄弟节点是黑色，且远侄子结点是红色（红红、黑红）（一次旋转，颜色互换）

   该情况将父结点和兄弟结点颜色互换，并进行左旋（或右旋）操作，最后把远侄子结点颜色变为黑色，并删除结点即可

4. 待删除结点的兄弟节点是黑色，且近侄子结点是红色，远侄子是黑色（红黑）

   先右旋（或左旋），并交换原兄弟结点和近侄子结点的颜色，则变成情况三

### 红黑树应用

高精度定时器

进程CFS公平调度

虚拟内存VMA管理

deadline and CFQ I/O 调度算法

文件系统ext4、btrfs等
